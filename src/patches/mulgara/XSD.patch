Index: src/jar/query/java/org/mulgara/query/rdf/XSD.java
===================================================================
--- src/jar/query/java/org/mulgara/query/rdf/XSD.java	(revision 560)
+++ src/jar/query/java/org/mulgara/query/rdf/XSD.java	(working copy)
@@ -29,15 +29,12 @@
 
 // Java 2 standard packages
 import java.net.URI;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.Locale;
-import java.text.SimpleDateFormat;
-import java.text.ParseException;
+import java.util.TimeZone;
 
-// Date utils
-import com.mousepushers.date.DateParser;
 import com.mousepushers.date.DateFormats;
-import com.mousepushers.date.DateFormatter;
 
 /**
  * XML Schema datatype constants.
@@ -158,7 +155,7 @@
    *
    * This is a highly abbreviated version of ISO 8601.
    */
-  public final static String DATE_TIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+  public final static String DATE_TIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSSZ";
 
   /**
    * Date format used by <code>xsd:gYear</code>.
@@ -172,8 +169,10 @@
 
   static {
     try {
-      ONE_BCE = DateParser.parse("0000", YEAR_FORMAT, Locale.getDefault());
-      ONE_CE = DateParser.parse("0001", YEAR_FORMAT, Locale.getDefault());
+      SimpleDateFormat df = new SimpleDateFormat(YEAR_FORMAT);
+      df.setTimeZone(TimeZone.getTimeZone("UTC"));
+      ONE_BCE = df.parse("0000");
+      ONE_CE = df.parse("0001");
     }
     catch (ParseException e) {
       // Should never be thrown
@@ -182,11 +181,11 @@
   }
 
   /**
-   * Returns the lexical form of the XSD dateTime value according to
-   * "3.2.7.2 Canonical representation" of
+   * Returns the timezoned (UTC) lexical form of the XSD dateTime value 
+   * according to "3.2.7.2 Canonical representation" of
    * http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/
    * with the following exceptions:
-   * - Timezones are not supported
+   * - "Local" or untimezoned dateTimes are treated as UTC. 
    * - Dates before 1 CE (i.e. 1 AD) are handled according to ISO 8601:2000
    *   Second Edition:
    *     "0000" is the lexical representation of 1 BCE
@@ -191,31 +190,29 @@
    *   Second Edition:
    *     "0000" is the lexical representation of 1 BCE
    *     "-0001" is the lexical representation of 2 BCE
-   * @return the lexical form of the XSD dateTime value
+   * @return the lexical form of the XSD dateTime value, e.g. 
+   *         "2006-11-13T09:40:55.001Z".
    */
   public static String getLexicalForm(Date date) {
     StringBuffer lexicalForm;
-    String dateTime = DateFormatter.formatDate(date, XSD.DATE_TIME_FORMAT,
-        Locale.getDefault());
-    int len = dateTime.length();
-    if (dateTime.indexOf('.', len - 4) != -1) {
-      while (dateTime.charAt(len - 1) == '0') {
-        len--;
-      }
-      if (dateTime.charAt(len - 1) == '.') {
-        len--;
-      }
-      lexicalForm = new StringBuffer(dateTime.substring(0, len));
+    SimpleDateFormat df = new SimpleDateFormat(XSD.DATE_TIME_FORMAT);
+    df.setTimeZone(TimeZone.getTimeZone("UTC"));
+    String dateTime = df.format(date);
+    
+    int len = dateTime.length() - 5; // less the signed timezone, i.e. +0000
+    while (dateTime.charAt(len - 1) == '0') {
+      len--;
     }
-    else {
-      lexicalForm = new StringBuffer(dateTime);
+    if (dateTime.charAt(len - 1) == '.') {
+      len--;
     }
+    lexicalForm = new StringBuffer(dateTime.substring(0, len));
+    lexicalForm.append('Z');
 
     if (date.before(ONE_CE)) {
-      StringBuffer year = new StringBuffer(String.valueOf(Integer.parseInt(
-          DateFormatter.formatDate(date, YEAR_FORMAT, Locale.getDefault())) - 1));
-      while (year.length() < 4)
-          {
+      df.applyPattern(XSD.YEAR_FORMAT);
+      StringBuffer year = new StringBuffer(String.valueOf(Integer.parseInt(df.format(date)) - 1));
+      while (year.length() < 4) {
         year.insert(0, '0');
       }
       lexicalForm.replace(0, lexicalForm.indexOf("-", 4), year.toString());

