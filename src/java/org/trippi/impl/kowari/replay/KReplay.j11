package org.trippi.impl.kowari.replay;

import java.io.*;
import java.net.*;
import java.text.*;
import java.util.*;

import org.apache.log4j.xml.*;

import org.jrdf.graph.*;

import org.kowari.itql.*;
import org.kowari.server.*;
import org.kowari.server.driver.*;
import org.kowari.server.local.*;
import org.kowari.query.*;
import org.kowari.query.rdf.*;

// These classes are ONLY used for -minimize mode,
// not for actual replaying
import org.trippi.TripleIterator;
import org.trippi.TriplestoreConnector;
import org.trippi.TriplestoreReader;
import org.trippi.TriplestoreWriter;
import org.trippi.impl.sesame.SesameConnector;

public class KReplay {

    public static String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS";

    private boolean m_shouldReplay;
    private int m_chunkSize;
    private File m_outFile;

    private Date m_startTime;
    private Date m_endTime;
    private double m_delay;
    private int m_gc = -1;
    private File m_memLog;
    private boolean m_memConsole = false;

    private ReplayLog m_log;

    private URI m_modelURI;
    private LocalSessionFactory m_factory;
    private JRDFSession m_session;

    ///////////////////////////////////////////////////////////////////////////

    public KReplay(Date start, 
                   Date end, 
                   double delay, 
                   String serverSpec, 
                   int gc,
                   File memLog,
                   File logFile) throws Exception {

        if (delay < 0) throw new Exception("Negative value specified for delay");

        m_gc = gc;
        m_memLog = memLog;
        if (m_memLog != null) {
            m_memConsole = true;
            if (m_memLog.getName().equals("console")) m_memLog = null;
        }

        m_log = new ReplayLog(logFile, start, end);

        boolean started = false;
        try {
            if (serverSpec == null) serverSpec = "replay#replay@/tmp/kowari-replay";
            startKowari(serverSpec);
            started = true;
            m_shouldReplay = true;
        } finally {
            if (!started) m_log.close();
        }

    }

    public KReplay(Date start,
                   Date end,
                   File logFile,
                   int chunkSize,
                   File outFile) throws Exception {
        m_log = new ReplayLog(logFile, start, end, 50, false);
        m_chunkSize = chunkSize;
        m_outFile = outFile;
        m_shouldReplay = false;
    }

    public void go() throws Exception {
        if (m_shouldReplay) {
            replay();
        } else {
            minimize();
        }
    }

    private void printTempStatus(int tc, Date logDate) {
        System.out.println(toString(new Date()) + " logDate = " + toString(logDate) + " triples = " + tc);
    }

    // m_chunkSize, m_outFile
    private void minimize() throws Exception {
        File tempBase = null;
        TriplestoreConnector tempStore = null;
        FileOutputStream outStream = null;
        try {
            // prepare the temporary triple store
            tempBase = new File("/tmp/kreplay-minimize-hash");
            int n = 0;
            while (tempBase.exists()) {
                n++;
                tempBase = new File("/tmp/kreplay-minimize-hash-" + n);
            }
            tempBase.mkdirs();
            tempStore = new SesameConnector();
            Map config = new HashMap();
            config.put("storageType", "native");
            config.put("dir", tempBase.getPath());
            config.put("autoFlushDormantSeconds", "100");
            config.put("autoFlushBufferSize", "500");
            config.put("bufferSafeCapacity", "1000");
            config.put("bufferFlushBatchSize", "500");
            tempStore.init(config);

            // get all add and del actions in order while updating tempStore
            System.out.println("Creating temporary triplestore using add/delete actions...");
            int ac = 0;
            int tc = 0;
            Action action = null;
            while (m_log.hasNext()) {
                action = m_log.next();
                ac++; // action count
                if (ac == 1000) {
                    printTempStatus(tc, action.getDate());
                    ac = 0;
                }

                int type = action.getType();
                if (type == Action.ADD) {
                    tc += action.getTriples().size();
                    tempStore.getWriter().add(action.getTriples(), false);
                } else if (type == Action.DEL) {
                    tc -= action.getTriples().size();
                    tempStore.getWriter().delete(action.getTriples(), false);
                }
            }
            tempStore.getWriter().flushBuffer();
            printTempStatus(tc, action.getDate());

            // enumerate everything in the tempstore, writing chunks to the outfile
            System.out.println("Serializing tempstore as new replay log: " + m_outFile.getPath());
            outStream = new FileOutputStream(m_outFile);
            PrintWriter writer = new PrintWriter(outStream, true);
            TripleIterator iter = tempStore.getReader().findTriples(null, null, null, -1);
            try {
                int num = m_chunkSize;
                while (iter.hasNext()) {
                    num++;
                    if (num > m_chunkSize) {
                        writer.println("\n" + toString(new Date()) + " add");
                        System.out.print(".");
                        num = 0;
                    }
                    writer.println(SimpleTriple.toString(iter.next()));
                }
                System.out.println("DONE");
            } finally {
                try { iter.close(); } catch (Exception e) { }
            }
        } finally {
            m_log.close();
            if (tempStore != null) try { tempStore.close(); } catch (Exception e) { }
            if (tempBase != null) {
                File[] files = tempBase.listFiles();
                for (int i = 0; i < files.length; i++) {
                    files[i].delete();
                }
                tempBase.delete();
            }
            if (outStream != null) try { outStream.close(); } catch (Exception e) { }
        }
    }

    private void replay() throws Exception {
        PrintWriter memWriter = null;
        try {
            if (m_memLog != null) {
                memWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(m_memLog)), true);
            }
            int c = 0;
            int gcc = 0;
            int i = 99;
            long st = System.currentTimeMillis();
            while (m_log.hasNext()) {
                Action action = m_log.next();
                c++;
                gcc++;
                if (gcc == m_gc) {
                    System.gc();
                    gcc = 0;
                }
                i++;
                if (i == 200) {
                    System.out.println("\n" + new SimpleDateFormat(DATE_FORMAT).format(new Date()) + " at action #" + c + " from " + new SimpleDateFormat(DATE_FORMAT).format(action.getDate()));
                    i = 0;
                }
                if (m_memConsole) {
                    long free = Runtime.getRuntime().freeMemory();
                    System.out.print("[" + free + "]" + action.toShortString());
                    if (memWriter != null) {
                        long elapsed = System.currentTimeMillis() - st;
                        memWriter.println(elapsed + " " + free);
                    }
                } else {
                    System.out.print(action.toShortString());
                }
                doAction(action);
            }
            long dur = System.currentTimeMillis() - st;
            System.out.println("\n\nFinished!  Replayed " + c + " actions in " + dur + "ms.");
        } finally {
            if (memWriter != null) {
                memWriter.close();
            }
            m_log.close();
        }
    }

    private static Set toSet(List list) {
        Set set = new HashSet();
        Iterator iter = list.iterator();
        while (iter.hasNext()) {
            set.add(iter.next());
        }
        return set;
    }

    private void doAction(Action action) throws Exception {
        if (action.getType() == Action.ADD) {
            m_session.insert(m_modelURI, toSet(action.getTriples()));
        } else if (action.getType() == Action.DEL) {
            m_session.delete(m_modelURI, toSet(action.getTriples()));
        } else if (action.getType() == Action.SPO) {
            try {
                Triple t = action.getPattern();
                Answer ans = m_session.find(m_modelURI, t.getSubject(), t.getPredicate(), t.getObject());
                try {
                    ans.beforeFirst();
                    int c = 0;
                    while (ans.next()) {
                        c++;
                    }
                    System.out.print(c);
                } finally {
                    try { ans.close(); } catch (Exception e) { System.out.println("Error closing answer:"); e.printStackTrace(); }
                }
            } catch (Exception e) {
                System.out.println("\n\nGot error doing spo query from " + new SimpleDateFormat(DATE_FORMAT).format(action.getDate()));
                e.printStackTrace(System.out);
                System.out.print("\nContinuing...");
            }
        } else if (action.getType() == Action.ITQ) {
            try {
                Answer ans = m_session.query(new ItqlInterpreter(new HashMap()).parseQuery(action.getQuery()));;
                try {
                    ans.beforeFirst();
                    int c = 0;
                    while (ans.next()) {
                        c++;
                    }
                    System.out.print(c);
                } finally {
                    try { ans.close(); } catch (Exception e) { System.out.println("Error closing answer:"); e.printStackTrace(); }
                }
            } catch (Throwable e) {
                System.out.println("\n\nGot error doing itql query from " + new SimpleDateFormat(DATE_FORMAT).format(action.getDate()));
                e.printStackTrace(System.out);
                System.out.print("\nContinuing...");
            }
        } else {
            throw new Exception("Unrecognized action type: " + action.getType());
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    private static String toString(Date date) {
        try {
            return new SimpleDateFormat(DATE_FORMAT).format(date);
        } catch (Exception e) { // won't happen
            return null;
        }
    }

    private void startKowari(String serverSpec) throws Exception {
        String[] parts = serverSpec.split("@");
        if (parts.length == 2) {
            String[] leftParts = parts[0].split("#");
            if (leftParts.length == 2) {
                String serverName = leftParts[0];
                String modelName = leftParts[1];
                String path = parts[1];

                URI serverURI = new URI("rmi://localhost/" + serverName);
                URI xsdModelURI = new URI(serverURI.toString() + "#xsd");
                m_modelURI = new URI(serverURI.toString() + "#" + modelName);

                System.out.println("Opening Kowari session...");
                m_factory = (LocalSessionFactory) 
                            SessionFactoryFinder.newSessionFactory(serverURI);
                try {
                    m_factory.setDirectory(new File(path));
                    m_session = (JRDFSession) m_factory.newJRDFSession();
                    ensureModelExists(xsdModelURI, new URI("http://tucana.org/tucana#XMLSchemaModel"));
                    ensureModelExists(m_modelURI, Session.KOWARI_MODEL_URI);
                } catch (Exception e) {
                    e.printStackTrace(System.err); 
                    stopKowari();
                }
            } else {
                throw new Exception("Expected one '#' delimiter in serverSpec");
            }
        } else {
            throw new Exception("Expected one '@' delimiter in serverSpec");
        }
    }

    private void ensureModelExists(URI modelURI, URI modelType) throws Exception {
        if (!m_session.modelExists(modelURI)) {
            System.out.println("Creating new model: " + modelURI.toString());
            m_session.createModel(modelURI, modelType);
        } else {
            System.out.println("Using existing model: " + modelURI.toString());
        }
    }

    public void stopKowari() {
        if (m_session != null) {
            System.out.println("Closing Kowari Session...");
            try { 
                m_session.close(); 
            } catch (Exception e) { }
        }
        try { m_factory.close(); } catch (Exception e) { }
    }

    ///////////////////////////////////////////////////////////////////////////

    private static void showUsageAndExit(String message) {
        System.err.println();
        if (message != null) {
            System.err.println("ERROR: " + message);
            System.err.println();
        }
        System.err.println("Usage: kreplay [-start    2005-09-01T14:44:21.021]");
        System.err.println("               [-end      2005-09-01T15:02:03.892]");
        System.err.println("               [-delay    .5]");
        System.err.println("               [-server   serverName#modelName@/path/to/baseDir]");
        System.err.println("               [-minimize 10000@/path/to/minimized-replay.log]");
        System.err.println("               [-gc       100]");
        System.err.println("               [-memlog   console|filename.dat]");
        System.err.println("               /path/to/replay.log");
        System.err.println();
        System.err.println("Where: -start Specifies the timestamp to start from.  If unspecified,");
        System.err.println("              replay will start at the beginning of the replay log.");
        System.err.println("         -end Specifies the timestamp to end with.  If unspecified,");
        System.err.println("              replay will end at end of the replay log.");
        System.err.println("       -delay Specifies how fast the replay will occur in terms of a delay");
        System.err.println("              multiplier.  0 will cause it to run as fast as possible, .5");
        System.err.println("              will cause it to run at double speed, 2 will cause it to");
        System.err.println("              run at half-speed, and so on.  If unspecified, the replay");
        System.err.println("              will run at original speed.");
        System.err.println("      -server Specifies the Kowari server where the replays will occur.");
        System.err.println("              If unspecified, replay#replay@/tmp/kowari-replay will be used.");
        System.err.println("              The local kowari database will be created if it doesn't exist.");
        System.err.println("    -minimize This can be used to create a minimized replay.log file that ");
        System.err.println("              contains only the add commands necessary to re-create the store.");
        System.err.println("              If this option is specified, the -delay and -server commands are");
        System.err.println("              irrelevant and will be ignored.  The value specified for this");
        System.err.println("              command indicates the chunk size and output filename.");
        System.err.println("          -gc The number of actions after which garbage collection will be");
        System.err.println("              requested.  If unspecified, garbage collection will never be");              
        System.err.println("              explicitly requested.");              
        System.err.println("      -memlog File to send gnu plottable memory log measurements to.");
        System.err.println("              If given as \"console\", memory measurements will be");
        System.err.println("              only be shown before each action on the console.");
        System.err.println("              If not specified, memory measurements will not be taken.");
        System.exit(1);
    }

    private static String getOpt(String name, 
                                 String[] args) throws Exception {
        for (int i = 0; i < args.length; i+=2) {
            if (args[i].equals("-" + name)) {
                if (args.length > i + 1) {
                    return args[i + 1];
                } else {
                    throw new Exception("Missing value for option: -" + name);
                }
            }
        }
        return null;
    }

    private static Date getOptAsDate(String name, 
                                     String[] args) throws Exception {
        String val = getOpt(name, args);
        if (val == null) return null;
        try {
            return new SimpleDateFormat(DATE_FORMAT).parse(val);
        } catch (Exception e) {
            throw new Exception("Bad date syntax for option: -" + name);
        }
    }

    private static double getOptAsDouble(String name, 
                                         String[] args, 
                                         double defaultValue) throws Exception {
        String val = getOpt(name, args);
        if (val == null) return defaultValue;
        try {
            return Double.parseDouble(val);
        } catch (Exception e) {
            throw new Exception("Expected a number for option: -" + name);
        }
    }

    private static int getOptAsInt(String name, 
                                      String[] args, 
                                      int defaultValue) throws Exception {
        String val = getOpt(name, args);
        if (val == null) return defaultValue;
        try {
            return Integer.parseInt(val);
        } catch (Exception e) {
            throw new Exception("Expected a number for option: -" + name);
        }
    }

    private static String getArg(int num, 
                                 String[] args, 
                                 String desc) throws Exception {
        int argNum = 0;
        for (int i = 0; i < args.length; i+=2) {
            if (!args[i].startsWith("-")) {
                if (num == argNum) {
                    return args[i];
                }
                argNum++;
            }
        }
        throw new Exception("Required argument missing: " + desc);
    }

    /**
     * Command-line entry point.
     */
    public static void main(String[] args) {

        KReplay replay = null;
        try {
            String home = System.getProperty("kreplay.home");
            if (home == null) throw new Exception("kreplay.home is not defined");
            DOMConfigurator.configure(new File(new File(home), "lib/log4j.xml").getPath());
            Date startTime = getOptAsDate("start", args);
            Date endTime   = getOptAsDate("end", args);
            double delay   = getOptAsDouble("delay", args, 1.0);
            String server  = getOpt("server", args);
            String mini    = getOpt("minimize", args);
            String memLog  = getOpt("memlog", args);
            File memLogFile = null;
            if (memLog != null) {
                memLogFile = new File(memLog);
            }
            int gc         = getOptAsInt("gc", args, -1);
            String logPath = getArg(0, args, "/path/to/replay.log");
            if (mini == null) {
                replay = new KReplay(startTime, endTime, delay, server, gc, memLogFile, new File(logPath));
            } else {
                // parse int@filename
                String[] parts = mini.split("@");
                if (parts.length == 2) {
                    int chunkSize;
                    try {
                        chunkSize = Integer.parseInt(parts[0]);
                    } catch (Exception e) {
                        throw new Exception("Error parsing minimize value: first part must be an integer."); 
                    }
                    replay = new KReplay(startTime, endTime, new File(logPath), chunkSize, new File(parts[1]));
                } else {
                    throw new Exception("Error parsing minimize value: must contain one @ sign.");
                }
            }
        } catch (Exception e) {
            showUsageAndExit(e.getMessage());
        }

        try {
            replay.go();
        } catch (Exception e) {
            e.printStackTrace(System.err);
        } finally {
            replay.stopKowari();
        }

    }

}