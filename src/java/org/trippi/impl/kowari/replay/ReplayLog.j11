package org.trippi.impl.kowari.replay;

import java.io.*;
import java.net.*;
import java.text.*;
import java.util.*;

import org.jrdf.graph.*;

public class ReplayLog extends Thread implements Serializable {

    public int MAX_BUFFER_SIZE;

    private File m_logFile;
    private Date m_earliest;
    private Date m_latest;
    private Date m_start;
    private Date m_end;

    private boolean m_stopThread;
    private List m_buffer;
    private Action m_next;
    private boolean m_sawLast;

    private String m_nextLine = "";

    /**
     * Construct a replay log with a buffer size of 25, validating it first.
     */
    public ReplayLog(File logFile, Date start, Date end) throws Exception {
        this(logFile, start, end, 25, true);
    }

    public ReplayLog(File logFile, Date start, Date end, int bufferSize, boolean validate) throws Exception {
        MAX_BUFFER_SIZE = bufferSize;
        m_logFile = logFile;
        if (validate) validate(true);
        m_start = start;
        if (m_start == null) m_start = m_earliest;
        if (m_start == null) m_start = new Date(0);
        m_end = end;
        if (m_end == null) m_end = m_latest;
        if (m_end == null) m_end = new Date(Long.MAX_VALUE);
        System.out.println("Using replay log from " + toString(m_start) + " to " + toString(m_end)); 
        m_buffer = new ArrayList();
        m_stopThread = false;
        m_sawLast = false;
        start();
        m_next = getNext();
    }

    public void run() {
        InputStream in = null;
        try {
            in = new FileInputStream(m_logFile);
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            Action action = getNextAction(reader);

            // read ahead till we get to the first action in the timeframe
            while (action != null && action.getDate().getTime() < m_start.getTime()) {
                action = getNextAction(reader);
            }

            // enter the main loop, which adds actions to the buffer till 
            // it has reached it's max size, then waits till it needs more,
            // and so on.  this loop will exit if action == null (we're at
            // the end of the interesting input) or m_stopThread is set.
            while (!m_stopThread && action != null && action.getDate().getTime() <= m_end.getTime()) {

                // add the action to the buffer
                int bufSize;
                synchronized (m_buffer) {
                    m_buffer.add(action);
                    bufSize = m_buffer.size();
                }

                // wait till the buffer needs more or m_stopThread is true
                while (!m_stopThread && bufSize >= MAX_BUFFER_SIZE) {
                    try {
                        Thread.sleep(250);
                    } catch (Exception e) {
                    }
                    synchronized (m_buffer) {
                        bufSize = m_buffer.size();
                    }
                }
               
                // get the next action
                action = getNextAction(reader);
            }

            // if we're past the interesting input, or the input is exhausted,
            // add the terminating item to the buffer
            if (action == null || action.getDate().getTime() > m_end.getTime()) {
                synchronized (m_buffer) {
                    m_buffer.add("end");
                }
            }
            
        } catch (Exception e) {
            System.err.println("ERROR! Unexpected error reading replay log. Aborted reading.");
            e.printStackTrace(System.err);
            synchronized (m_buffer) {
                m_buffer.add("end");
            }
        } finally {
            try { in.close(); } catch (Exception e) { }
        }
    }

    /**
     * Parse and return the next Action from the given BufferedReader,
     * or return null if we've reached the end of the underlying stream.
     */
    private Action getNextAction(BufferedReader reader) throws Exception {
        String line = m_nextLine;
        while (line.length() == 0) {
            line = reader.readLine();
            if (line == null) return null;
            line = line.trim();
        }
        String[] parts = line.split(" ");
        Date actionDate = new SimpleDateFormat(KReplay.DATE_FORMAT).parse(parts[0]);
        int actionType = Action.getType(parts[1]);
        line = reader.readLine();

        if (actionType == Action.SPO) {
            // parse the just-read line as a Triple pattern
            m_nextLine = "";
            return new Action(actionDate, parseTriple(line.trim()));
        } else if (actionType == Action.ADD || actionType == Action.DEL) {
            // parse triples till end
            List triples = new ArrayList();
            while (line != null && line.length() > 0) {
                triples.add(parseTriple(line.trim()));
                line = reader.readLine(); 
            }
            m_nextLine = "";
            return new Action(actionDate, actionType, triples);
        } else {
            // must be a non-spo query... read it into a buffer
            StringBuffer buf = new StringBuffer();
            int c = 0;
            while (line.length() > 0) {
                if (c > 0) buf.append("\n");
                buf.append(line.trim());
                c++;
                line = reader.readLine();
                if (line.equals("")) {
                    m_nextLine = reader.readLine();
                    while (m_nextLine != null && !m_nextLine.startsWith("2")) {
                        buf.append("\n" + m_nextLine.trim());
                        m_nextLine = reader.readLine();
                    }
                    if (m_nextLine == null) return null;
                }
                if (line == null) line = "";
            }
            return new Action(actionDate, actionType, buf.toString());
        }
    }

    public boolean hasNext() {
        return m_next != null;
    }

    public Action next() {
        Action thisAction = m_next;
        m_next = getNext();
        return thisAction;
    }

    private Action getNext() {
        if (m_sawLast) return null;
        // wait for the buffer to have one or more items, then pop the first
        while (true) {
            synchronized (m_buffer) {
                if (m_buffer.size() > 0) {
                    Object o = m_buffer.remove(0);
                    if (o instanceof String) {
                        m_sawLast = true;
                        return null;
                    } else {
                        return (Action) o;
                    }
                }
            }
            try {
                Thread.sleep(25);
            } catch (Exception e) {
            }
        }
    }

    public void close() {
        m_stopThread = true;
    }

    public void finalize() {
        close();
    }

    private Triple parseTriple(String tripleString) throws Exception {
        String[] parts = tripleString.split(" ");
        String subject = parts[0];
        String predicate = parts[1];
        StringBuffer buf = new StringBuffer();
        for (int i = 2; i < parts.length; i++) {
            if (i > 2) buf.append(" ");
            buf.append(parts[i]);
        }
        String object = buf.toString();
        return new SimpleTriple((SubjectNode) parseNode(subject),
                                (PredicateNode) parseNode(predicate),
                                (ObjectNode) parseNode(object));
    }

    private Node parseNode(String n) throws Exception {
        if (n.equals("*")) {
            return null;
        } else {
            char c = n.charAt(0);
            if (c == '<' && n.length() > 4) {   // <a:b>
                return new SimpleURIReference(new URI(stripFirstAndLast(n)));
            } else if ( ( c == '"' || c == '\'' ) && n.length() > 1) { // ''
                int i = n.lastIndexOf(c);
                if ( i == n.length() - 1 ) {
                    return new SimpleLiteral(unescapeLiteral(stripFirstAndLast(n)));
                } else {
                    String uriString = n.substring(1, i);
                    String qualifier = n.substring(i + 1);
                    if (qualifier.startsWith("@")) {
                        return new SimpleLiteral(uriString, qualifier.substring(1));
                    } else if (qualifier.startsWith("^^")) {
                        return new SimpleLiteral(uriString, new URI(qualifier.substring(2)));
                    } else {
                        throw new Exception("Malformed literal: " + n);
                    }
                }
            } else {
                throw new Exception("Could not parse node: " + n);
            }
        }
    }

    private static String stripFirstAndLast(String s) {
        StringBuffer out = new StringBuffer();
        for (int i = 1; i < s.length() - 1; i++) {
            out.append(s.charAt(i));
        }
        return out.toString();
    }

    private static String unescapeLiteral(String s) {
        StringBuffer out = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '\\') {
                char d = s.charAt(++i);
                out.append(d);
            } else {
                out.append(c);
            }
        }
        return out.toString();
    }

    private void validate(boolean printStats) throws Exception {
        System.out.println("Validating " + m_logFile.getPath() + "...");
        int spoCount = 0;
        int itqCount = 0;
        int addCount = 0;
        int delCount = 0;
        Date earliest = null;
        Date latest = null;
        InputStream in = new FileInputStream(m_logFile);
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            String line = reader.readLine();
            boolean inAction = false;
            int lineNum = 0;
            while (line != null) {
                lineNum++;
                line = line.trim();
                if (!inAction) {
                    if (line.length() > 0) {
                        String[] parts = line.split(" ");
                        if (parts.length != 2) {
                            throw new Exception("Log invalid: Line " + lineNum + ": Expected DATE (space) ACTION_TYPE");
                        }
                        try {
                            Date d = new SimpleDateFormat(KReplay.DATE_FORMAT).parse(parts[0]);
                            if (earliest == null) earliest = d;
                            latest = d;
                            String action = parts[1];
                            if (action.equals("spo")) {
                                spoCount++;
                            } else if (action.equals("itq")) {
                                itqCount++;
                            } else if (action.equals("add")) {
                                addCount++;
                            } else if (action.equals("del")) {
                                delCount++;
                            } else {
                                throw new Exception("Log invalid: Line " + lineNum + ": Unrecognized action: " + action);
                            }
                        } catch (Exception e) {
                            throw new Exception("Log invalid: Line " + lineNum + ": Malformed date");
                        }
                        inAction = true;
                    }
                    line = reader.readLine();
                } else {
                    // we're in an action... keep reading 'till we see a line
                    // that starts with '2' or line == null
                    while (line != null && !line.startsWith("2")) {
                        line = reader.readLine();
                    }
                    inAction = false;
                }
            }
            if (earliest == null) throw new Exception("Log invalid: No dated entries found");
            m_earliest = earliest;
            m_latest = latest;
            if (printStats) {
                System.out.println("Replay Log Stats: earliest date: " + toString(earliest));
                System.out.println("                  latest date  : " + toString(latest));
                System.out.println("                  add count    : " + addCount);
                System.out.println("                  del count    : " + delCount);
                System.out.println("                  itq count    : " + itqCount);
                System.out.println("                  spo count    : " + spoCount);
            }
        } finally {
            in.close();
        }
    }

    private static String toString(Date d) {
        try {
            return new SimpleDateFormat(KReplay.DATE_FORMAT).format(d);
        } catch (Exception e) { // won't happen
            return null;
        }
    }

}