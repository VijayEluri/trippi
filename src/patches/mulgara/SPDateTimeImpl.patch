Index: src/jar/store-stringpool/java/org/mulgara/store/stringpool/xa/SPDateTimeImpl.java
===================================================================
--- src/jar/store-stringpool/java/org/mulgara/store/stringpool/xa/SPDateTimeImpl.java	(revision 560)
+++ src/jar/store-stringpool/java/org/mulgara/store/stringpool/xa/SPDateTimeImpl.java	(working copy)
@@ -30,19 +30,16 @@
 // Java 2 standard packages
 import java.net.URI;
 import java.nio.ByteBuffer;
+import java.text.DateFormat;
 import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.Locale;
+import java.util.TimeZone;
 
-// Third party packages
 import org.apache.log4j.Category;
-
-// Date utils
-import com.mousepushers.date.DateParser;
-
-// Locally written packages
 import org.mulgara.query.rdf.XSD;
-import org.mulgara.store.stringpool.*;
+import org.mulgara.store.stringpool.AbstractSPTypedLiteral;
+import org.mulgara.store.stringpool.SPComparator;
 import org.mulgara.util.Constants;
 
 
@@ -99,12 +96,20 @@
     this(new Date(l));
   }
 
-
+  /**
+   * Static factory method for SPDateTimeImpl.
+   * @param lexicalForm canonical representation of XSD dateTime, e.g.
+   *        "2006-11-13T09:40:55.001Z".
+   * @return <code>SPDateTimeImpl</code>
+   */
   static SPDateTimeImpl newInstance(String lexicalForm) {
 
-    StringBuffer sb = new StringBuffer(lexicalForm);
-    int pos = sb.length() - 4;
+    StringBuffer sb = new StringBuffer(getNormalizedTimezone(lexicalForm));
+    String timezone = sb.substring(sb.length() - 5);
+    sb.delete(sb.length() - 5, sb.length());
+    int pos = sb.length() - 4; // e.g. ".123"
     int index = sb.indexOf(".", pos);
+    // Normalize lexicalForm to match XSD.DATE_TIME_FORMAT
     if (index == -1) {
       sb.append(".000");
     }
@@ -109,7 +114,7 @@
       sb.append(".000");
     }
     else {
-      if (index == sb.length() - 1) {
+      if (index == sb.length() - 1) { // e.g. dateTime ending "00."
         throw new IllegalArgumentException("Cannot parse date: " + lexicalForm);
       }
       int pad = pos - index;
@@ -118,10 +123,13 @@
         pad++;
       }
     }
+    sb.append(timezone);
     lexicalForm = sb.toString();
+
     try {
-      Date date = DateParser.parse(lexicalForm, XSD.DATE_TIME_FORMAT,
-          Locale.getDefault());
+      DateFormat df = new SimpleDateFormat(XSD.DATE_TIME_FORMAT);
+      df.setTimeZone(TimeZone.getTimeZone("UTC"));
+      Date date = df.parse(lexicalForm);
       return new SPDateTimeImpl(date);
     }
     catch (ParseException ex) {
@@ -144,11 +152,11 @@
   }
 
   /**
-   * Returns the lexical form of the XSD dateTime value according to
-   * "3.2.7.2 Canonical representation" of
+   * Returns the timezoned (UTC) lexical form of the XSD dateTime value 
+   * according to "3.2.7.2 Canonical representation" of
    * http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/
    * with the following exceptions:
-   * - Timezones are not supported
+   * - "Local" or untimezoned dateTimes are treated as UTC. 
    * - Dates before 1 CE (i.e. 1 AD) are handled according to ISO 8601:2000
    *   Second Edition:
    *     "0000" is the lexical representation of 1 BCE
@@ -153,7 +161,8 @@
    *   Second Edition:
    *     "0000" is the lexical representation of 1 BCE
    *     "-0001" is the lexical representation of 2 BCE
-   * @return the lexical form of the XSD dateTime value
+   * @return the lexical form of the XSD dateTime value, e.g. 
+   *         "2006-11-13T09:40:55.001Z".
    */
   public String getLexicalForm() {
     return XSD.getLexicalForm(date);
@@ -189,7 +198,34 @@
       return false;
     }
   }
-
+  
+  /**
+   * Normalize the time zone of an XSD dateTime to a signed RFC 822 4-digit time
+   * zone format, e.g. "+0800" or "-1100".
+   * 
+   * This method assumes <code>lexicalForm</code> is a valid lexical 
+   * representation of an XSD dateTime.
+   * 
+   * @param lexicalForm
+   * @return the XSD dateTime with a signed, 4 digit time zone
+   */
+  private static String getNormalizedTimezone(String lexicalForm) {
+      StringBuffer sb = new StringBuffer(lexicalForm);
+      final String UTC = "+0000";
+      if (sb.charAt(sb.length() -1) == 'Z') {
+          sb.replace(sb.length() - 1, sb.length(), UTC);
+          return sb.toString();
+      }
+      
+      int lb = sb.lastIndexOf("T") + 8; // e.g. the '5' in "T01:23:45"
+      if (sb.indexOf("+", lb) == -1 && 
+              sb.indexOf("-", lb) == -1) {
+          sb.append(UTC); // treat lexicalForm as untimezoned
+      } else if (sb.charAt(sb.length() -3) == ':') {
+          sb.deleteCharAt(sb.length() -3);
+      }
+      return sb.toString();
+  }
 
   /** Compares the binary representations of two SPDateTimeImpl objects. */
   public static class SPDateTimeComparator implements SPComparator {

